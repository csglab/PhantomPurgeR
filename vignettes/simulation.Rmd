---
title: "PhantomPurgeR: Vignette"
author: "Rick Farouni"
package: PhantomPurgeR
date: "`r Sys.Date()`"
output: BiocStyle::html_document
vignette: >
  %\VignetteIndexEntry{Converting BUS format into sparse matrix}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---



# Preparations

```{r}
library(tidyverse)
library(poibin)
library(combinat)
library(furrr)
library(tictoc)
library(data.table)
library(matrixStats)
library(rprojroot)
library(cowplot)
plan(multiprocess)
library(PhantomPurgeR)
```

```{r, echo=FALSE, results="hide", message=FALSE}
require(knitr)
opts_chunk$set(error=FALSE, message=FALSE, warning=FALSE)
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
options(future.globals.maxSize= +Inf, future.fork.enable=TRUE)
```


```{r}
figures_dir <- file.path("./figures")
```

## Define Functions






```{r}
create_data <- function(prob, rmax, nreads){
  dt <- 
    tibble(r=1:rmax,
           s=dgeom(r-1, prob[1]) ) %>% 
    mutate(s=(s/sum(s))) %>%
    mutate(rs= r*s)
  
  RMR <-sum(dt %>% pull(rs))
  nmol <- nreads/RMR
  
  dt <- 
    dt %>% 
    mutate(s= round(nmol*s))%>%
    select(-rs)
  
return(dt)
}

simulate_pi <- function(prob , rmax, nreads=3e7 ){
  
  sample_names <- paste0("s", 1:length(prob))
  names(prob)  <- sample_names 
  
  dt <-
    map_dfr(prob, 
            create_data,
            rmax=rmax,
            nreads=nreads,
            .id="sample") %>%
    spread(sample, s)
  
  dt_summary <-
    dt %>%
    select(-r) %>%
    summarize_all(sum) %>%
    gather(sample, nmols) %>%
    mutate(RMR=nreads/nmols,
           pgeom_prob=prob,
           p_molecs=nmols/sum(nmols))
  
  dt <- dt %>%
    mutate(sum_mols = rowSums(.[sample_names])) %>%
    mutate_at(vars(sample_names), ~ . / sum_mols) %>%
    mutate(m= sum_mols/sum(sum_mols))

return(list(Pi=dt, summary=dt_summary))
}

plot_Pi <- function(Pi, Pi_marginal) {
 p1 <-
    ggplot(Pi %>%
      select(
        -sum_mols
      ) %>%
      gather(sample, p, -c("r"))) +
    geom_line(aes(
      x = r,
      y = p,
      colour = sample
    ),
    size = 1,
    alpha = 1
    ) +
    geom_point(
      data = pi_out$Pi %>%
        select(r, m),
      aes(x = r, y = m),
      shape = 10,
      size = 1,
      alpha = .9
    ) +
    theme_bw() +
    geom_hline(
      data = Pi_marginal,
      aes(
        yintercept = p_molecs,
        colour = sample
      ),
      size = 0.3,
      linetype = "longdash",
      alpha = 1
    ) +
    labs(
      x = "r (PCR duplicates)",
      y = "proportion"
    ) +
    scale_colour_viridis_d(
      option = "inferno",
      direction = -1
    ) +
    theme(
      axis.title.x = element_text(size = rel(1.4)),
      axis.title.y = element_text(size = rel(1.4)),
      axis.text = element_text(size = rel(1.3)),
      legend.title = element_text(size = rel(1.1), face = "bold"),
      legend.text = element_text(size = rel(1.1))
    )
return(p1)
}

```

```{r}
get_product_logsum <- function(x, y) {
  z_log <- log(x) + log(y)
  z <- exp(z_log)
  return(z)
}


generate_outcomes_s <- function(s, p, S, r, pi_r){
  p_h <- (1 - p) / (S - 1)
  pvec <- rep(p_h, S)
  pvec[s] <- p
  pi_r_s <- pi_r[s]

  outcomes <- xsimplex(S, r)
  
  pmf <- apply(outcomes,
               2,
               dmnom,
               prob = pvec)
  
  outcomes <- outcomes  %>% 
                t() %>%
                as_tibble( .name_repair = "unique") %>%
    setNames(paste0("y", 1:S)) %>%
    mutate(pmf_rs=pmf,
           pmf_r=get_product_logsum(pmf, pi_r_s))
  
 return(outcomes)
}



create_grouping_vars <- function(outcomes, S) {
  
  s <- 
    outcomes %>%
    pull(s) %>%
    as.numeric()
  
  
  setDT(outcomes)

  outcomes[,
       outcome := do.call(paste, c(.SD, sep = ",")),
       .SDcols = paste0("y", 1:S)]

  outcome <-
    outcomes %>%
    pull(outcome)
  
  outcomes <-
    outcomes  %>%
    select(c(paste0("y", 1:S))) %>%
    as.matrix
  
  
  y_s <- as.integer(outcomes[cbind(seq_along(s), s)] != 0)
  

  r <- as.integer(rowSums2(outcomes))
  k_chimera <- as.integer(S - rowCounts(outcomes, value = 0))
  fantoms <- k_chimera - y_s
  #n_hopped <- as.integer(r - rowMaxs(outcome_counts))
  
  
  
  s_frac_1 <-
    apply(cbind(outcomes,r),
          1,
          function(x) {
            y <- which(x[1:S] >=  (x[S + 1] * 0.6))
            y <- unname(y)
            if (length(y) == 0)
              y <- 0
            return(y)
          })
  
  s_frac_2 <-
    apply(cbind(outcomes,r),
          1,
          function(x) {
            y <- which(x[1:S] >=  (x[S + 1] * 0.8))
            y <- unname(y)
            if (length(y) == 0)
              y <- 0
            return(y)
          })

   
    s_frac_3 <-
    apply(cbind(outcomes,r),
          1,
          function(x) {
            y <- which(x[1:S] >=  (x[S + 1]* 1.0))
            y <- unname(y)
            if (length(y) == 0)
              y <- 0
            return(y)
          })
  
  grouping_vars <- tibble(outcome=outcome,
                          r = r,
                          s_frac_1 = s_frac_1,
                          s_frac_2 = s_frac_2,
                          s_frac_3 = s_frac_3,
                          fantoms =fantoms,
                          k_chimera = k_chimera)
                          
  return(grouping_vars)
}


add_vars_to_outcome_counts <- function(outcomes, S) {
  
  grouping_vars <- create_grouping_vars(outcomes,S) 
  outcomes <- bind_cols(outcomes, grouping_vars)  
  
  return(outcomes)
  
}


infer_sample_of_origin_outcome <- function(..., pi_r, log_zi, S, p) {
  y <- c(...)[1:S]
  log_sample_pi <- log(pi_r)
  #log_zi <- c(...)[2*S+1]
  #zi_vec <- rep(zi, S)
  #posterior_s <- zi_vec ^ y
  posterior_s <- y * log_zi + log_sample_pi

  ## normalize to the sample with maximum posterior probability
  posterior_s <- posterior_s - max(posterior_s)
  posterior_s <- exp(posterior_s)

  posterior <- posterior_s / sum(posterior_s)
  q <- max(posterior)
  s_hat <- which.max(posterior)

out <- list(s_hat = s_hat, q = q)
  return(out)
}


add_posterior_prob <- function(outcomes, S, p, pi_r) {
  
  log_zi <- log((S - 1)) - log(1 / p - 1)
  
  posteriors <-
    future_pmap_dfr(
      outcomes %>%
        select(paste0("y", 1:S)),
      infer_sample_of_origin_outcome,
      pi_r=pi_r,
      log_zi = log_zi,
      S=S,
      p=p
    )
  
  outcomes <- bind_cols(outcomes %>%
                          select(-c(paste0("y", 1:S))),
                        posteriors)
  
  return(outcomes)
  
}



generate_outcomes <- function(...,p, S){
  
    r <- c(...)[1]
    pi_r <- c(...)[2:(S+1)]

    
   outcomes <- future_map_dfr(1:S,
                              generate_outcomes_s,
                              p=p,
                              S=S,
                              r=r,
                              pi_r=pi_r,
                              .id = "s")
     
     
    outcomes <- add_vars_to_outcome_counts(outcomes, S)
    

    
    outcomes <- add_posterior_prob(outcomes, S, p, pi_r) 
    
    
   outcomes <- 
     outcomes %>%
     mutate(s= as.integer(s) ,
            s_frac_1= as.integer(s_frac_1),
            s_frac_2= as.integer(s_frac_2),
            s_frac_3= as.integer(s_frac_3),
            r=as.integer(r))
    
  return(outcomes)
}


evaluate_classification <- function(outcomes) {
  

  outcomes <- 
  outcomes %>%
  mutate(
         hit_s= s==s_hat,
         hit_frac_1= s==s_frac_1,
         hit_frac_2= s==s_frac_2,
         hit_frac_3= s==s_frac_3,
         k_chimera_p=get_product_logsum(k_chimera, pmf),
         fantoms_p=get_product_logsum(fantoms, pmf),
         g=(1-(k_chimera-fantoms))*pmf,
         qr = 1 - q)  
  
g_total <-  
  outcomes %>%
  summarise_at(vars(c("g")), sum)  %>%
  pull(g)

outcomes<-
    outcomes %>%
    arrange(qr)%>%
    mutate(
      o = cumsum(pmf),
      FP = cumsum(get_product_logsum(
        qr,
        pmf
      )),
      FN=1 - o + FP-g_total,
      FPm= last(FP)- FP, # marginal
      FNm=FN-last(FN), # marginal
      tor=if_else(FPm <.Machine$double.neg.eps | FNm <.Machine$double.neg.eps,
                  0,
                  FNm/FPm),
      FP_1=case_when(
                   !hit_frac_1 & s_frac_1!=0 ~ pmf,
                   TRUE ~0),
      FN_1=case_when(s_frac_1==0 & g==0 ~ pmf,
                   !hit_frac_1 & s_frac_1!=0  & g==0 ~ pmf,
                   TRUE ~0),
      FP_2=case_when(
                   !hit_frac_2 & s_frac_2!=0 ~ pmf,
                   TRUE ~0),
      FN_2=case_when(s_frac_2==0 & g==0 ~ pmf,
                   !hit_frac_2 & s_frac_2!=0  & g==0 ~ pmf,
                   TRUE ~0),
      FP_3=case_when(
                   !hit_frac_3 & s_frac_3!=0 ~ pmf,
                   TRUE ~0),
      FN_3=case_when(s_frac_3==0 & g==0 ~ pmf,
                   !hit_frac_3 & s_frac_3!=0  & g==0 ~ pmf,
                   TRUE ~0))


  return(outcomes)
  
}


compute_classification_metrics <- function(p, torc=3){
  
  outcomes <-  
    future_pmap_dfr(pi_r_filtered,
                    generate_outcomes,
                    p=p,
                    S=S )

  outcomes <- 
  left_join(outcomes ,
            m_df, 
            by="r") %>%
    mutate(
         pmf= get_product_logsum(pmf_r,m))%>%
              select(-c("m","pmf_rs","pmf_r")) 

  outcomes <- evaluate_classification(outcomes) 


  tor_thresh <-
    outcomes %>%
    summarize(tor_thresh = tor[which.max(-pmax(tor, torc))]) %>%
    pull(tor_thresh)
  
  
  metrics_tor <-
    outcomes %>%
    filter(tor == tor_thresh) %>%
    select(FP, FN, tor) %>%
    rename(cutoff = "tor") %>%
    mutate(cutoff = paste0("tor_", str_sub(
      as.character(cutoff),
      start = 1,
      end = 4
    )))
  
  
  maxfrac_fp <-
    outcomes %>%
    summarise_at(vars(starts_with("FP_")), sum) %>%
    gather(condition, FP) %>%
    select(FP)
  
  maxfrac_fn <-
    outcomes %>%
    summarise_at(vars(starts_with("FN_")), sum)  %>%
    gather(condition, FN) %>%
    select(FN)
  
  metrics_dt <- bind_cols(maxfrac_fp,
                          maxfrac_fn) %>%
    
    mutate(cutoff = c("mf_0.60", "mf_0.80", "mf_1.00")) %>%
    bind_rows(., metrics_tor) %>%
    select(cutoff, everything())
  
  
  tor_dt <-
    outcomes %>%
    filter(tor < 10 & tor > 1 & g == 0) %>%
    mutate(tor = round(tor, 4)) %>%
    group_by(tor) %>%
    filter(row_number() == 1)
  
  
  return(list(tor_dt=tor_dt,  metrics_dt= metrics_dt))
}

plot_trade_off <- function(condition, condition_name){

condition$metrics_dt$cutoff[4] <- "tor_3"
  
p <- ggplot(condition$tor_dt) + 
    geom_line(
      aes(x = FP,
          y = FN),
      colour="grey")+
    geom_point(
      aes(x = FP,
          y = FN,
          color=tor),
      size=.5,
      alpha=.8)+
  scale_color_viridis_c() +
    labs(x="False Positives",
         y="False Negatives") +
    geom_point(data=condition$metrics_dt,
               aes(x = FP,
                   y = FN,
                   shape=cutoff),
               size=1.8,
               colour="brown")+
    theme_bw()  +
  #scale_y_sqrt()+
   theme(
     legend.title = element_text(face = "bold")
   ) +
   expand_limits(x = c(0, .005), y = c(0, 0.06))
  
 legend <- get_legend(p)
 p <- p + theme(legend.position = "none")

  p <- ggdraw() +
    draw_plot(p, 0, 0, 1, 1) +
    draw_label(paste0("p=", condition_name),
               x = 0,
               y = 1,
               vjust = 2,
               hjust = -1.8,
               size = 12,
               fontface = "italic"
    )

return(list(p=p, legend=legend))
}
```

## Simulate Molecular Complexity Profile 



```{r}
S <- 6
rmax <- 25
#a <- .3
#b <- .3
#prob <- (2*rbeta(S, a, b)/ 5) + 0.1 #min=.1, max=.5
prob1 <- c(0.5, 0.45, 0.3, 0.1, 0.07, 0.05)
prob2 <- c(0.5, 0.4, 0.3, 0.2, 0.1, 0.05)
prob3 <- c(0.4, 0.35, 0.3, 0.25, 0.2)
```

```{r}
pi_out <- simulate_pi(prob1, rmax)
```

```{r}
pi_out$summary
```


```{r fig.width=12}
plot_Pi(pi_out$Pi, pi_out$summary)
```












## Set maximum range of *r* and simulate *m* 

```{r}
m_df <- pi_out$Pi %>% select(r, m)
m_df
```

## Simulate outcomes


```{r}
pi_r_filtered <- pi_out$Pi %>% select(-m, -sum_mols)
pi_r_filtered
```

```{r}
pvec <- seq(0.982,0.998, by=.004)
names(pvec) <- pvec
pvec 
```


```{r message=FALSE, warning=FALSE}
metrics_list <-
  map(pvec, compute_classification_metrics)
```



```{r}
metrics_list
```

## Plot results

```{r, fig.width=12}
p_tradeoff <- imap(metrics_list, plot_trade_off)
p_list <- p_tradeoff %>% map(list("p"))
legend_list <- p_tradeoff %>% map(list("legend"))
p_tradeoff_all <- 
  plot_grid(
    plot_grid(
p_list[[1]],
                                   p_list[[2]],
                                   p_list[[3]], 
                                   p_list[[4]],
          align="hv",
          axis ="tblr"),
                 plot_grid(NULL, legend_list[[4]], NULL, ncol=1),
                 rel_widths=c(1, 0.1))
p_tradeoff_all
```






# save plot

```{r}
save_plot(file.path("simulation_tradoff4.pdf"), 
          p_tradeoff_all,
          ncol = 3, # we're saving a grid plot of 2 columns
          nrow = 2, # and 2 rows
          base_height=4,
          # each individual subplot should have an aspect ratio of 1.3
          base_aspect_ratio = 1
          )
```


```{r}
sessionInfo()
```


