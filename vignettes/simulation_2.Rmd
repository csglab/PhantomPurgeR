---
title: "R Notebook"
output: html_notebook
---

This is an [R Markdown](http://rmarkdown.rstudio.com) Notebook. When you execute code within the notebook, the results appear beneath the code. 

Try executing this chunk by clicking the *Run* button within the chunk or by placing your cursor inside it and pressing *Ctrl+Shift+Enter*. 





---
title: "PhantomPurgeR: Vignette"
author: "Rick Farouni"
package: PhantomPurgeR
date: "`r Sys.Date()`"
output: BiocStyle::html_document
vignette: >
  %\VignetteIndexEntry{Converting BUS format into sparse matrix}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---



# Preparations

```{r}
library(tidyverse)
library(poibin)
library(combinat)
library(furrr)
library(tictoc)
library(data.table)
library(matrixStats)
library(rprojroot)
library(cowplot)
plan(multiprocess)
library(PhantomPurgeR)
```

```{r, echo=FALSE, results="hide", message=FALSE}
require(knitr)
opts_chunk$set(error=FALSE, message=FALSE, warning=FALSE)
knitr::opts_knit$set(root.dir = rprojroot::find_rstudio_root_file())
options(future.globals.maxSize= +Inf, future.fork.enable=TRUE)
```


```{r}
figures_dir <- file.path("./figures")
```

## Define Functions






```{r}
create_data <- function(prob, rmax, nreads){
  dt <- 
    tibble(r=1:rmax,
           s=dgeom(r-1, prob[1]) ) %>% 
    mutate(s=(s/sum(s))) %>%
    mutate(rs= r*s)
  
  RMR <-sum(dt %>% pull(rs))
  nmol <- nreads/RMR
  
  dt <- 
    dt %>% 
    mutate(s= round(nmol*s))%>%
    select(-rs)
  
return(dt)
}

simulate_pi <- function(prob , rmax, nreads=3e7 ){
  
  sample_names <- paste0("s", 1:length(prob))
  names(prob)  <- sample_names 
  
  dt <-
    map_dfr(prob, 
            create_data,
            rmax=rmax,
            nreads=nreads,
            .id="sample") %>%
    spread(sample, s)
  
  dt_summary <-
    dt %>%
    select(-r) %>%
    summarize_all(sum) %>%
    gather(sample, nmols) %>%
    mutate(RMR=nreads/nmols,
           pgeom_prob=prob,
           p_molecs=nmols/sum(nmols))
  
  dt <- dt %>%
    mutate(sum_mols = rowSums(.[sample_names])) %>%
    mutate_at(vars(sample_names), ~ . / sum_mols) %>%
    mutate(m= sum_mols/sum(sum_mols))

return(list(Pi=dt, summary=dt_summary))
}

plot_Pi <- function(Pi, Pi_marginal) {
 p1 <-
    ggplot(Pi %>%
      select(
        -sum_mols
      ) %>%
      gather(sample, p, -c("r"))) +
    geom_line(aes(
      x = r,
      y = p,
      colour = sample
    ),
    size = 1,
    alpha = 1
    ) +
    geom_point(
      data = pi_out$Pi %>%
        select(r, m),
      aes(x = r, y = m),
      shape = 10,
      size = 1,
      alpha = .9
    ) +
    theme_bw() +
    geom_hline(
      data = Pi_marginal,
      aes(
        yintercept = p_molecs,
        colour = sample
      ),
      size = 0.3,
      linetype = "longdash",
      alpha = 1
    ) +
    labs(
      x = "r (PCR duplicates)",
      y = "proportion"
    ) +
    scale_colour_viridis_d(
      option = "inferno",
      direction = -1
    ) +
    theme(
      axis.title.x = element_text(size = rel(1.4)),
      axis.title.y = element_text(size = rel(1.4)),
      axis.text = element_text(size = rel(1.3)),
      legend.title = element_text(size = rel(1.1), face = "bold"),
      legend.text = element_text(size = rel(1.1))
    )
return(p1)
}

```









```{r}

get_product_logsum <- function(x, y) {
  z_log <- log(x) + log(y)
  z <- exp(z_log)
  return(z)
}


generate_outcomes_s <- function(s, p, S, r, pi_r){
  p_h <- (1 - p) / (S - 1)
  pvec <- rep(p_h, S)
  pvec[s] <- p
  pi_r_s <- pi_r[s]

  outcomes <- xsimplex(S, r)
  
  pmf <- apply(outcomes,
               2,
               dmnom,
               prob = pvec)
  
  outcomes <- outcomes  %>% 
                t() %>%
                as_tibble( .name_repair = "unique") %>%
    setNames(paste0("y", 1:S)) %>%
    mutate(pmf_rs=pmf,
           pmf_r=get_product_logsum(pmf, pi_r_s))
  
 return(outcomes)
}


create_grouping_vars <- function(outcomes, S) {
  
  s <- 
    outcomes %>%
    pull(s) %>%
    as.numeric()
  
  
  setDT(outcomes)

  outcomes[,
       outcome := do.call(paste, c(.SD, sep = ",")),
       .SDcols = paste0("y", 1:S)]

  outcome <-
    outcomes %>%
    pull(outcome)
  
  outcomes <-
    outcomes  %>%
    select(c(paste0("y", 1:S))) %>%
    as.matrix
  
  
  y_s <- as.integer(outcomes[cbind(seq_along(s), s)] != 0)
  

  r <- as.integer(rowSums2(outcomes))
  k_chimera <- as.integer(S - rowCounts(outcomes, value = 0))
  fantoms <- k_chimera - y_s
  #n_hopped <- as.integer(r - rowMaxs(outcome_counts))
  
  
  grouping_vars <- tibble(outcome=outcome,
                          r = r,
                          fantoms =fantoms,
                          k_chimera = k_chimera)
                          
  return(grouping_vars)
}


add_vars_to_outcome_counts <- function(outcomes, S) {
  
  grouping_vars <- create_grouping_vars(outcomes,S) 
  outcomes <- bind_cols(outcomes, grouping_vars)  
  
  return(outcomes)
  
}


generate_outcomes <- function(...,p, S){
  
    r <- c(...)[1]
    pi_r <- c(...)[2:(S+1)]

    
   outcomes <- future_map_dfr(1:S,
                              generate_outcomes_s,
                              p=p,
                              S=S,
                              r=r,
                              pi_r=pi_r,
                              .id = "s")
     
     
    outcomes <- add_vars_to_outcome_counts(outcomes, S)
    

    
    outcomes <- add_posterior_prob(outcomes, S, p, pi_r) 
    
    
   outcomes <- 
     outcomes %>%
     mutate(s= as.integer(s) ,
            s_frac_1= as.integer(s_frac_1),
            s_frac_2= as.integer(s_frac_2),
            s_frac_3= as.integer(s_frac_3),
            r=as.integer(r))
    
  return(outcomes)
}


generate_outcomes <- function(...,p, S){
  
    r <- c(...)[1]
    pi_r <- c(...)[2:(S+1)]

    
   outcomes <- future_map_dfr(1:S,
                              generate_outcomes_s,
                              p=p,
                              S=S,
                              r=r,
                              pi_r=pi_r,
                              .id = "s")
   
   outcomes <- add_vars_to_outcome_counts(outcomes, S)

     
    
   outcomes <- 
     outcomes %>%
     mutate(s= as.integer(s) ,
            r=as.integer(r))
    
  return(outcomes)
}


```



## Simulate Molecular Complexity Profile 



```{r}
S <- 6
p<- 0.986 
rmax <- 25
#a <- .3
#b <- .3
#prob <- (2*rbeta(S, a, b)/ 5) + 0.1 #min=.1, max=.5
prob1 <- c(0.5, 0.45, 0.3, 0.1, 0.07, 0.05)
prob2 <- c(0.5, 0.4, 0.3, 0.2, 0.1, 0.05)
prob3 <- c(0.4, 0.35, 0.3, 0.25, 0.2)
```

```{r}
pi_out <- simulate_pi(prob1, rmax)
```

```{r}
pi_out$summary
```


```{r fig.width=12}
plot_Pi(pi_out$Pi, pi_out$summary)
```



## Set maximum range of *r* and simulate *m* 

```{r}
m_df <- pi_out$Pi %>% select(r, m)
m_df
```

## Simulate outcomes


```{r}
pi_r_filtered <- pi_out$Pi %>% select(-m, -sum_mols)
pi_r_filtered
```






```{r}
  outcomes <-  
    future_pmap_dfr(pi_r_filtered,
                    generate_outcomes,
                    p=p,
                    S=S )

  outcomes <- 
  left_join(outcomes ,
            m_df, 
            by="r") %>%
    mutate(
         pmf= get_product_logsum(pmf_r,m))%>%
              select(-c("m","pmf_rs","pmf_r")) 
  
   outcomes
```
```{r}
n_mol_total <- sum(pi_out$summary$nmols)

outcomes %>%
  mutate(n_mol=k_chimera*n_mol_total*pmf)


```



```{r}
simulate_tags <- function(nmols, rmr, umi_length=10, barcode_length=737280,  ngenes=10000, disp=3, mu=10000){
  ncells <- round(nmols/mu)
  y <- rnbinom(ncells, mu=mu , size =disp) 
  dt <- 
    tibble(cell = rep(sample(barcode_length, length(y), replace = TRUE) -1L, y),
           umi = map(y, ~ sample(4L^as.integer(umi_length), ., replace = FALSE)) %>% unlist(),
           gene = map(y, ~ sample(seq(0, ngenes), ., replace = TRUE)) %>% unlist(),
           reads= map(y, ~ (rnbinom(., mu=rmr-1, size =1) + 1L))%>% unlist())
  
  dt <-dt[rep(1:length(dt$reads), dt$reads),1:3]
  
  return(dt)
}

```


```{r}
swap_reads <- function( dt, p =0.98){
  S <- 3
  p_h <- (1 - p) / (S - 1)
  s_counts <- table(dt$sample)
  sample_o <- vector(mode = "list", length = S)
  for (s in 1:S){
    pvec <- rep(p_h, S)
    pvec[s] <- p
    sample_o[s] <- apply(rmultinom(s_counts[s], 1, pvec)==1, 2, which)
  }
  
  dt <- 
    dt %>%
    mutate(sample_o= unlist(sample_o))
  return(dt)
}
```

```{r}
dt <- map2_dfr(c(3e7, 1e7, 3e6),
               c(2, 3, 10),
               simulate_tags,
               .id = "sample")

dt <- swap_reads(dt)
```


```{r}
    # out.files <- paste0(prefix, ".", seq_len(nsamples), ".h5")
    # version <- match.arg(version)
    # for (i in seq_along(out.files)) {
    #     sample <- seq_len(nsamples)[i]
    #     out.file <- out.files[i]
    #     if (file.exists(out.file)) {
    #         file.remove(out.file)
    #     }
    #     current <- fulltab[fulltab$sample == sample, ]
    #     h5 <- h5createFile(out.file)
    # 
    #     actual.barcodes <- factor(.unmask_barcode(current$cell, 
    #         barcode.length))
    #     h5write(as.integer(actual.barcodes) - 1L, out.file, 
    #         "barcode_idx")
    #     h5write(levels(actual.barcodes), out.file, "barcodes")
    #     h5write(current$gene, out.file, "feature_idx")
    #     h5write(current$reads, out.file, "count")
    #     h5createGroup(out.file, "features")
    #     h5write(array(sprintf("ENSG%i", seq_len(ngenes))), 
    #         out.file, "features/id")
    # 
    # h5write(current$umi, out.file, "umi")
    # h5write(rep(1L, nrow(current)), out.file, "gem_group")
    # 
    # return(out.files)
```


